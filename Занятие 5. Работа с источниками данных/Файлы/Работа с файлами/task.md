# Работа с файлами в Python

## Цель урока
После прохождения урока вы научитесь работать с файлами в Python, понимать различные режимы работы с файлами и использовать менеджер контекста для безопасного открытия и закрытия файлов.

### Режимы работы с файлами

При работе с файлами в Python можно выбрать различные режимы работы, которые определяют, как файл будет открыт и какие операции можно выполнять.

- **Текстовый режим (`'t'`)**: Это режим работы по умолчанию.  
  Файл открывается как текстовый файл, и все операции выполняются над текстовыми данными.  
  Текстовые данные представляются в виде строк.
- **Бинарный режим (`'b'`)**: Файл открывается в бинарном режиме, и операции выполняются над байтовыми данными.  
  В бинарном режиме данные представляются в виде последовательности байтов.
  
### Режимы доступа к файлу

Помимо режимов работы, существуют режимы доступа к файлу:

- **Чтение (`'r'`)**: Открывает файл для чтения.  
  Если файл не существует, возникает ошибка. Это режим доступа по умолчанию. 
- **Запись (`'w'`)**: Открывает файл для записи.  
  Если файл не существует, создает новый файл.  
  Если файл существует, удаляет его содержимое.
- **Дозапись (`'a'`)**: Открывает файл для добавления данных в конец файла.  
  Если файл не существует, создает новый файл.
- **Перезапись (`'x'`)**: Открывает файл для записи.  
  Если файл существует, возникает ошибка.

### Менеджер контекста

Python предоставляет удобный способ работы с файлами с использованием менеджера контекста (`with`).  
Менеджер контекста автоматически открывает файл, выполняет операции и закрывает файл, даже в случае возникновения исключений.  
Это гарантирует безопасное открытие и закрытие файла.

Пример использования менеджера контекста для работы с файлами:

```python
with open('file.txt', 'rt') as f:  # Открытие файла file.txt на чтение в текстовом режиме
    # выполняем операции с файлом
    # файл автоматически закрывается по завершении блока кода
    ...
```

### Чтение файла

Для чтения содержимого файла в Python можно использовать метод `read()`.  
Он возвращает строку, содержащую все содержимое файла.

```python
with open("filename.txt") as f:  # Если не указать второй аргумент, то файл откроется на чтение в текстовом режиме
    content = f.read()  # Метод read считывает весь файл
    print(content)
```

### Запись в файл

Для записи данных в файл в Python можно использовать метод `write()`.  
Он записывает переданную строку в файл.

```python
with open("filename.txt", "w") as f:  # Открытие файла запись в текстовом режиме
    f.write("Hello, world!")
```

Если файл уже существует, его содержимое будет удалено и перезаписано новыми данными.

### Дозапись в файл

Для дозаписи данных в конец файла в Python можно использовать метод `write()` в режиме `a`.

```python
with open("filename.txt", "a") as f:  # Открытие файла на дозапись
    f.write("This is a new line.")
```

Новая строка будет добавлена в конец файла без удаления существующего содержимого.

### Построчное чтение файла

Чтение файла построчно можно осуществить с помощью цикла `for`:

```python
with open("filename.txt") as f:
    for line in f:  # Цикл for умеет работать с файлами построчно
        print(line)
```

### Кодировка файла
Кодировка файла определяет, как символы исходного текста в файле представлены в виде последовательности байтов.  
Кодировка задает правила для преобразования символов в числовое представление (обычно в виде байтов) и обратно.

Когда вы открываете текстовый файл, программа должна знать, какую кодировку использовать для правильного интерпретации содержимого файла.  
Неверное определение кодировки может привести к неправильному отображению символов и ошибкам при чтении или записи файла.

Существует множество различных кодировок файлов, включая ASCII, UTF-8 и многие другие.  
Каждая кодировка имеет свои особенности и поддерживает различный набор символов.

ASCII (American Standard Code for Information Interchange) - это стандартный набор символов, используемых для представления текста на компьютерах и других устройствах связи, работающих с текстом.  
Каждому символу в наборе ASCII соответствует уникальный числовой код, который может быть представлен в виде 7 или 8 бит.

Оригинальный набор ASCII включает 128 символов, которые включают латинские буквы (A-Z, a-z), цифры (0-9), знаки пунктуации и некоторые специальные символы, такие как пробел, новая строка и табуляция.  
Коды ASCII могут быть представлены в виде чисел от 0 до 127 (или от 0 до 255, если используется 8-битное представление).

Например, ниже приведена таблица с некоторыми символами ASCII и их соответствующими десятичными кодами:

```
Десятичный код | Символ
---------------+-------
      65       |   A
      66       |   B
      97       |   a
      98       |   b
      48       |   0
      49       |   1
      32       | пробел
      10       | новая строка
```


UTF-8 является одной из наиболее популярных кодировок, которая широко используется для представления текста на разных языках.  
Она поддерживает большой набор символов и представляет символы, используя переменное число байтов.

### Аргумент `encoding`

При работе с текстовыми файлами в Python, особенно если вы работаете с не-ASCII символами, может потребоваться указать правильную кодировку файла.  
Для этого используется аргумент `encoding`.

Аргумент `encoding` позволяет указать кодировку, в которой будет открыт файл.  
Например, `encoding="utf-8"` указывает, что файл должен быть открыт в кодировке UTF-8.

Пример использования аргумента `encoding` при открытии файла для чтения:

```python
with open('file.txt', encoding="utf-8") as file:
    # выполняем операции с файлом
    ...
```

Если не указывать аргумент `encoding`, будет использоваться кодировка, установленная по умолчанию на вашей системе.

Корректное указание кодировки важно, чтобы правильно обрабатывать и отображать символы в текстовых файлах.  
Это особенно важно, когда работаете с различными языками или специальными символами.

## Задание
Запустите исходную версию скрипта. Проанализируйте вывод и содержимое созданного файла `output.txt`.  
Затем добавьте аргумент `encoding='utf-8'` при записи файла, перезапустите скрипт и проверьте результаты.
